% -*- mode: Noweb; noweb-code-mode: caml-mode -*-
% vim: ts=8 et sw=4:

% ------------------------------------------------------------------ 
\section{The compiler driver (in Lua)}
% ------------------------------------------------------------------ 

The compiler is driven by a Lua script [[qc--.lua]]
that the built-in Lua interpreter executes at startup.  The script is
searched along a search path by an {\ocaml} function in module
\module{main.nw}. As a default, the script presented here is compiled
into the {\qcc} binary and executed unless the user has made special
arrangements.

<<qc--.lua>>=
$debug 1
-- 
-- This Lua code is generated from the following file that also includes
-- the documentation. Do not edit this file directly.
--
-- $Id$
--

<<Lua utility functions>>
<<Debugging Tools>>
<<Lua code for registers>> -- defined in ../rtl/register.nw
<<Lua compiler configuration>> -- defined in luacompile.nw

SysConfig = {}
SysConfig["x86-linux"] =
 { Ld =
   { path    = "cc"
   , options = "-I" .. Config.install_inc
   , rtstart = ""
   , objects = ""
   , libs    = ""
   , rtend   = "-L" .. Config.install_lib .. " -lqc-- " ..
              Config.install_lib .. "/pcmap.ld"
   }
 , As = { path = "as", options = "" }
 , backend = Backend.x86
 }
SysConfig["sparc-solaris"] =
 { Ld =
   { path    = "gcc"
   , options = "-I" .. Config.install_inc
   , rtstart = ""
   , objects = ""
   , libs    = "-lm"
   , rtend   = ""
   }
 , As = { path = "as", options = "-xarch=v8" }
 , backend = Backend.sparc
 }
SysConfig["powerpc-darwin"] =
 { Ld =
   { path    = "cc"
   , options = "-I" .. Config.install_inc
   , rtstart = ""
   , objects = ""
   , libs    = ""
   , rtend   = "-L" .. Config.install_lib .. " -lqc-- " ..
              Config.install_lib .. "/pcmap.ld"
   }
 , As = { path = "as", options = "" }
 , backend = Backend.ppc
 }

<<Lua command-line driver>>

Frontends = Frontends or { }

backend = SysConfig[Boot.arch_os].backend  -- can be changed on command line

-- 
-- Everything starts from here
--

CMD.parse(Sys.argv)
backend = backend or Backend.dummy; _ = [[ ... ]]
if backend == nil then error(
    "running on unknown platform; can't select backend automatically.\n"
 .. "Please use backend=Backend.xxx or edit luadriver.nw to select\n"
 .. "backend based on the platform")
end    
CMD.whatfuns[CMD.what or "-compile"]()
CMD.remove_derived_files()
@ 
\subsection{Interface}

To keep the Lua name space clean, related functionality is grouped into
tables which are used like modules. By convention, the names of tables
are capitalized.
Here is some documentation.

\smallskip

\noindent
\begin{tabularx}{\linewidth}{|lX|}
\hline
[[As.cmd(o, s)]]& Command to assemble file [[s]] and place the results
in file~[[o]].\\
[[Ld.cmd(o)]]& Command to link all object files, libraries, and so
on, placing the results
in file~[[o]].\\
\hline
[[CMD.parse]]& Parse the command line and set values in [[Options]].\\
[[CMD.what]]&
  String saying what the driver should do on this run (default is
  [[-compile]]).\\
[[CMD.whatfuns]]&
  Table of functions, indexed by string in [[CMD.what]], which
actually do the job of the driver.\\
[[CMD.derived]]&
  List of derived files.\\
[[CMD.qslist]]&
  List of [[.qs]] files to be linked if using the interpreter.\\
[[CMD.translate]]&
  A function that translates a file by dispatching on the canonical
  extension in [[CMD.txtab]].
  It is called on each file to be compiled.\\
[[CMD.txtab]]&
  A table mapping each canonical extension to a function that
  translates that extension, then returns any derived files that should
  be translated.
  Normally initialized either to [[CMD.compilertab]] or [[CMD.interptab]].\\
[[CMD.extensiontab]]&
  A table giving the ``canonical'' form of each alternative extension.
  For example, \texttt{.a} and \texttt{.so} are alternatives for the
  canonical form~\texttt{.o}, and \texttt{.cmm} is an alternative for
  the canonical form~\texttt{.c--}.\\
[[CMD.canonical_extension]]&
  A function that takes a file name and returns its ``canonical''
  extension.
  Uses [[CMD.extensiontab]].\\
\hline
[[Options.stop]]&
  Set of extensions with which translation should stop.\\
[[Options.stop_count]]&
  Size of [[Options.stop]].\\
[[Options.stop_at]]&
  Add an item to [[Options.stop]]\\
[[Options.the_stop]]&
  Function returning the extension, if any, at which to stop translating.\\
[[Options.keep]]&
  Set of extensions that should be kept (as derived files) or nil to
  keep all.
  Any derived file with extension in [[Options.stop]] is also kept.\\
\hline
\end{tabularx}\\
It would probably be useful to have an [[optfuns]] as the counterpart
of [[whatfuns]], so that other compilers could add new options.
@
The most interesting flow is the ``compile'' flow, which does this as
governed by [[Options.stop]]:
\begin{verbatim}
            <source>
               |
             .c--
           /   |   \
         .s   .qs  .pp
          |
         .o
\end{verbatim}


% ------------------------------------------------------------------ 
\subsection{Options table}
% ------------------------------------------------------------------ 

Command-line parsing is implemented in Lua. The command line is passed
as a list to [[CMD.parse]], which records the results in the
[[Options]] table as well as in the variable [[CMD.what]], which
tells what the driver should do---the default is to compile
the files on the command
line. 
<<Lua command-line driver>>=
Options = Options  or {}

Options.verbose    = 0     -- -v
Options.output     = nil   -- -o
Options.keep       = { }   -- extensions of derived files to keep (nil to keep all)
Options.argc       = 0     -- number of argument files
Options.argv       = {}    -- argv[1], .. , argv[argc]
Options.globals    = nil   -- don't emit globals
Options.validate   = 1     -- check against target's capability record
@ 
Here we handle the semantics of the [[-keep]] options.
<<Lua command-line driver>>=
function Options.do_keep(v)
  if v == 'all' then
    Options.keep = nil
  elseif strfind(v, '^%.') then
    Options.keep[v] = 1
  else
    CMD.error('in -keep x, x must be "all" or an extension, not ' .. v)
  end
end
@ 
The standard compilation path may be told to stop before linking.
If so, stopping is identified by the extension at which to stop.
I originally conceived of [[Options.stop]] as a set, but it should contain at
most one element, so this may not be the best representation.
<<Lua command-line driver>>=
Options.stop       = { }
Options.stop_count = 0

function Options.stop_at(ext) -- insert ext into stop set
  if Options.stop[ext] == nil then
    if Options.stop_count == 0 then
      Options.stop[ext] = 1
      Options.stop_count = Options.stop_count + 1
    else
      CMD.error('Cannot stop translating after both ' ..
                Options.the_stop() .. ' and ' .. ext)
    end
  end
end

function Options.the_stop()
  return next(Options.stop, nil)
end
@
\subsection{Assembly and linking support}
The command-line driver calls an external assembler and linker.
They are configured using the [[As]] and [[Ld]] tables, 
and an appropriate command is created by calling [[As.cmd]] or [[Ld.cmd]].

WE OUGHT TO BE USING [[Caml.Filename.quote]] HERE AND ELSEWHERE.
<<Lua command-line driver>>=
As = As and error ('As not empty') or {}

As.path    = SysConfig[Boot.arch_os].As.path    -- binary 
As.options = SysConfig[Boot.arch_os].As.options -- options passed to binary
function As.cmd(out, in)
  return format('%s %s -o %s %s', As.path, As.options, out, in)
end
@  
Having strings everywhere is a bit of a cheat---more abstraction might
be useful (especially if we ever care to handle a file with a space or
metacharacter in
its name).

The fields [[rtstart]], [[rtend]], and [[libs]] are there for
front-end [[.lua]] files to assign to.
<<Lua command-line driver>>=
Ld = Ld and error ('Ld not empty') or {}
Ld.path     = SysConfig[Boot.arch_os].Ld.path -- binary
Ld.options  = SysConfig[Boot.arch_os].Ld.options -- options
Ld.rtstart  = SysConfig[Boot.arch_os].Ld.rtstart -- initial run-time system
Ld.objects  = SysConfig[Boot.arch_os].Ld.objects -- object files from this compilation
Ld.libs     = SysConfig[Boot.arch_os].Ld.libs -- libraries and library options
Ld.rtend    = SysConfig[Boot.arch_os].Ld.rtend
                            -- trailing run-time system

function Ld.cmd(exe)
  return
    format ("%s %s -o %s %s %s %s %s",
            Ld.path, Ld.options, exe, Ld.rtstart, Ld.objects, Ld.libs, Ld.rtend)
end
@
\subsection{The driver and its supporting functions}
All logic for the command line is encapsulated in the [[CMD]] module.
Any error causes the process to exit.
<<Lua command-line driver>>=
Test = Test and error('Test not empty') or {}
CMD = CMD and error('CMD not empty') or {}
CMD.what = nil -- set by CMD.parse
CMD.whatfuns = { }
CMD.derived = { }
CMD.qslist = { }
CMD.exit = exit  -- may be reset for better handling
@ 
When the dust settles, we remove derived files (or not, according to
the settings of [[Options.stop]] and [[Options.keep]]).
<<Lua command-line driver>>=
function CMD.remove_derived_files()
  local i = 1
  while CMD.derived[i] do
    local d = CMD.derived[i]
    if Options.stop[Caml.Filename.extension(d)] or not Options.keep or
       Options.keep[Caml.Filename.extension(d)]
    then
       -- do nothing
    else
       CMD.exec('rm ' .. d)
    end
    i = i + 1
  end
end
@ 
Driver code should use [[CMD.error]] to indicate an error during
compilation or on the command line.  
The built-in Lua [[error]] should be reserved for an internal error
that should never happen.
<<Lua command-line driver>>=
function CMD.error (msg)
    write ("Error: " .. msg .. "\n")
    CMD.exit(2)
end    
@ 
Depending on the verbosity level, commands are silently executed (0),
shown before executions (1), only shown, but not executed (2).
<<Lua command-line driver>>=
function CMD.exec(cmd)
  if Options.verbose == 1 then write(format("executing: %s\n", cmd)) end
  if Options.verbose == 2 then 
      write(format("simulating: %s\n", cmd)) 
  else
      if execute(cmd) ~= 0 then CMD.exit(1) end
  end    
end
@ 
The [[CMD.parse]] function parses the list of command-line arguments.
The results are recorded in the global table [[Options]] and in [[CMD.what]].

Files to be compiled are accumulated in the variable [[Options.argv]], using
[[Options.argc]] as an index to the last argument. The files in [[argv]]
are compiled and linked in this order. Since linking is sensitive to
order, we treat options like [[-L]] and [[-l]] as files.

I WOULD LIKE TO RETIRE [[-c]] AND [[-S]] IN FAVOR OF [[-stop]].
<<Lua command-line driver>>=
function CMD.parse (args)
  local O = Options
  local i = 1
  while args[i] and type(args[i]) == "string" do
    local v = args[i]
    if CMD.whatfuns[v] then
      if not CMD.what or CMD.what == v then CMD.what = v
      else CMD.error('options ' .. CMD.what .. ' and ' .. v ..
                     ' are mutually incompatible')
      end
    elseif v == "-c"       then O.stop_at(".o")
    elseif v == "-S"       then O.stop_at(".s"); O.stop['.qs'] = 1
                                if O.keep then O.keep['.qs'] = 1 end
    elseif v == "-v"       then O.verbose = O.verbose + 1
    elseif v == "-vv"      then O.verbose = O.verbose + 2
    elseif v == "-globals" then O.globals = 1  -- emit globals for 1 file
    elseif strfind(v, "=") then local _ = dostring(v) or CMD.exit(2)
    elseif v == "-o" then 
        i,v    = i+1, args[i+1] or CMD.error("argument for option -o missing") 
        O.output = v
    elseif v == "-e" then 
        CMD.dashe = 1
        i, v   = i+1, args[i+1] or CMD.error("argument for option -e missing")
        local _ = dostring(v) or CMD.exit(2)
    elseif v == "-keep" then 
        i, v   = i+1, args[i+1] or CMD.error("argument for option -keep missing")
        O.do_keep(v)
    elseif v == "-stop" then 
        i, v   = i+1, args[i+1] or CMD.error("argument for option -stop missing")
        O.stop_at(v)
    elseif strfind(v, '^-') and not strfind(v, '^-[lL]') then
        CMD.error("unknown option: ".. v, 1)
    elseif strfind(v, '%.lua$') then -- evaluate right away
        local _ = Util.dosearchfile(v) or CMD.exit(2)
    else -- it is a file or is -L or -l and must be treated as a file
        O.argc         = O.argc + 1
        O.argv[O.argc] = v 
    end
    i = i+1
  end
  if O.output and O.stop_count > 0 and O.argc > 1 then
    CMD.error('You cannot translate multiple files with -o option and ' ..
              'also stop at ' .. O.the_stop())    
  end
end
@
\subsection{Simple, relatively boring driver functions}
\paragraph {Interactive Lua loop with \texttt{-i}}
The [[-i]]~option triggers a read--eval loop that gives the user
interactive access to the interpreter. This is most useful for debugging
Lua code.
<<Lua command-line driver>>=
function CMD.whatfuns["-i"] ()
    local prompt = "\n  "
    local stmt
    write ("-- This is Lua-ML for "); Driver.version()
    write ("-- Call Inspect.globals() to dump name space")
    
    write(prompt)
    stmt = read()
    while stmt ~= nil do
        dostring(stmt)
        write(prompt)
        stmt = read()
    end           
end
@
\paragraph {Help with \texttt{-help}}
Simple command-line options are implemented in the [[CMD]] module
directly. 
<<Lua command-line driver>>=
function CMD.whatfuns["-help"]()
  write(CMD.help)
end
CMD.help = [[
qc-- [option | file] ...

qc-- processes options from left to right, and then all file name
arguments from left to right.

-c          Stop compiling after producing .o files
-S          Stop compiling after producing .s files
-keep .ext  Keep derived files whose names end in .ext
-keep all   Keep all derived files
-o output   Name the output file output.  If -o is not used,
            the output file defaults to "a.out".
-Ldir       Add dir to the library search path. 
-lname      Add library name to the list of libraries to be searched. 
-interp     Generate code for qc--interp(1).
-v          Print commands as they are executed. 
-version    Print version to stdout and stop with exit code 0.
-help       Summarize options to stdout and stop with exit code 0.
-man        Write manual page to stdout and stop with exit code 0.
var=value   Assign the variable var in qc--'s Lua interpreter the 
            new value. 

See also: qc--(1), qc--internals(1), http://www.cminusminus.org/.            
]]
@ 
\paragraph {A manual page with \texttt{-man}}
<<Lua command-line driver>>=
-- The manual page is automatically included into the qc-- binary and 
-- available as Boot.manual from within Lua.

CMD.manpage = Boot.manual
function CMD.whatfuns["-man"]()
  write(CMD.manpage)
end
@ 
\paragraph {Version info with \texttt{-version}}
<<Lua command-line driver>>=
-- Boot.version writes to a channel such that you cannot use the version
-- to control program behavior. 

function CMD.whatfuns["-version"] ()
    write ("Quick C-- Version ")
    Boot.version(Driver.stdout) 
    write ("\n")
end    
@
\subsection{Interesting driver functions for the compiler and interpreter}

\paragraph{The dispatch loop}

The compiler and interpreter have this in common: they loop over files
and dispatch on the extensions.
But for each file, the compiler uses one translation function and the
interpreter uses another.
This function is [[CMD.translate]], or by default, the function passed
to [[translate_files]].

When a file is translated, it may return additional files to be
translated, and so on until completion.
<<Lua command-line driver>>=
function CMD.translate_files(files, txtab)
  if Options.argc == 0 and not CMD.dashe then CMD.whatfuns["-help"](); CMD.exit(1) end
  if txtab then CMD.txtab = CMD.txtab or txtab end --- set translator's table
  if files then
    if type(files) == 'string' then
      local ext = CMD.canonical_extension(files)
      if not Options.stop[ext] then
        CMD.translate_files(CMD.translate(files, txtab), txtab)
      end
    else
      local i = 1
      while files[i] do
        CMD.translate_files(files[i], txtab)
        i = i+1
      end
    end
  end
end
@ 
Translating a single file dispatches on its canonical extension in [[CMD.txtab]].
<<Lua command-line driver>>=
function CMD.translate(file, txtab)
  -- write("CMD.translate: "..file.."\n")
  txtab = txtab or CMD.txtab
  if txtab[CMD.canonical_extension(file)] then
    return txtab[CMD.canonical_extension(file)](file)
  elseif txtab['unrecognized extension'] then
    -- write('treating as unrecognzied file: '..file..'\n')
    txtab['unrecognized extension'](file)
  else  
    CMD.error('qc-- does not recognize extension of file ' .. file)
  end
end
@ 
The ``canonical extension'' business treats [[-l]] or [[-L]] options
as object files, plus it keeps a table of synonyms.
<<Lua command-line driver>>=
CMD.extensiontab = { }
CMD.extensiontab['.cmm'] = '.c--'
CMD.extensiontab['.a']   = '.o'
CMD.extensiontab['.so']  = '.o'

function CMD.canonical_extension(file) 
  if strfind(file, '^-[lL]') then
    return '.o'
  else
    local ext = Caml.Filename.extension(file)
    return CMD.extensiontab[ext] or ext
  end
end
@ 
But they use different tables and different linking commands.
<<Lua command-line driver>>=
function CMD.whatfuns["-compile"]()
  CMD.translate_files(Options.argv, CMD.compilertab)
  if Options.stop_count == 0 and Ld.objects ~= "" then
    CMD.exec(Ld.cmd(Options.output or 'a.out'))
  elseif Options.verbose > 0 then
    if Options.stop_count == 0 then
      write('Stopping at ', Options.the_stop(), '\n')
    else
      write('Nothing to link\n')
    end
  end    
end

function CMD.whatfuns["-interp"]()
  backend = Backend.interp -- no choice here!
  CMD.translate_files(Options.argv, CMD.interptab)
  if Options.stop_count == 0 then
    CMD.qs2exe(CMD.qslist, Options.output) 
  elseif Options.verbose > 0 then
    write('Stopping at ', Options.the_stop(), '\n')
  end    
end
@ 
The prettyprinter is an odd sort of ``compiler.''
I haven't tested it.
<<Lua command-line driver>>=
function CMD.whatfuns["-pp"]()
  local O = Options
  if O.argc > 1 and O.output then
    CMD.error("Cannot specify -o and -pp with multiple inputs")
  end
  O.stop_at('.pp')
  CMD.translate_files(Options.argv, CMD.prettytab)
end
@
\paragraph{Deriving files}
There are many points at which we have to choose a name for an
intermediate file or output file. 
We know the original file and the extension.
If we are stopping with this extension, and if an output file is
supplied, we should use that output file.
Otherwise, we create a derived file.
(Sometimes the extension to check can be different from the extension
of the derived file; for example, when we derive a [[.qs]] we check
for [[.s]].)
<<Lua command-line driver>>=
function CMD.outfilename(file, ext, extcheck)
  if Options.stop[extcheck or ext] and Options.output then 
    return Options.output
  else
    local tmp = Caml.Filename.chop_extension(file) .. ext
    tinsert(CMD.derived, tmp)
    return tmp
  end
end
@ \emph{In a just world, we would invent unique names for derived files
that won't survive, and we would place them in a temporary directory.
To do so, we would have to track the ``base'' file name, e.g.,
so from \texttt{foo.c--} we could create \texttt{/tmp/asdf239874.s}
but then \texttt{foo.o}.
For now, this is too much trouble---but it will return to bite us is
people compile from a directory that is not writable.}
@
\paragraph{Compiler's actions for known file types}

The compiler  looks up the canonical extension in [[CMD.compilertab]],
and if there is no corresponding function, we give up.
<<Lua command-line driver>>=
CMD.compilertab = { }
@ 
A Lua file is interpreted for side effect.
If an error occurs, we exit.
<<Lua command-line driver>>=
function CMD.compilertab[".lua"](file) 
  CMD.error("Internal error --- .lua file made it to second pass")
end
@ 
{\PAL} source is translated to assembly code.
We recognize extension [[.cmm]] as well as [[.c--]].
<<Lua command-line driver>>=
function CMD.compilertab[".c--"](file) 
  local asm = CMD.outfilename(file, '.s')
  if Options.verbose > 0 then write('Translating ', file, ' to ', asm, '\n') end
  local emitglobals = Options.globals
  if emitglobals == 1 then Options.globals = nil end
  if Options.verbose < 2 then backend.compile(backend, emitglobals, file, asm) end
  return asm
end
@ 
We get from assembly to object file by calling the assembler.
<<Lua command-line driver>>=
function CMD.compilertab[".s"](file) 
  local obj = CMD.outfilename(file, '.o')
  CMD.exec(As.cmd(obj, file))
  return obj
end
@ 
An object file is salted away in [[Ld.objects]].
I'm slightly embarrassed to use strings here.
<<Lua command-line driver>>=
function CMD.compilertab[".o"](file) 
  -- write("treating as object file: "..file.."\n")
  Ld.objects = Ld.objects .. " " .. file
end
@ 
Unknown extensions are treated like object files: they are passed to the
linker.
<<Lua command-line driver>>=
CMD.compilertab["unrecognized extension"]=CMD.compilertab[".o"]
@
The compiler barfs if given interpreter's assembly code.
<<Lua command-line driver>>=
function CMD.compilertab[".qs"](file)
  CMD.error('file ' .. file .. ' is for the Quick C-- interpreter, not native code')
end
@ 

\paragraph{Interpreter's actions for known file types}
<<Lua command-line driver>>=
CMD.interptab = { }
@ 
Just as in the compiler, a Lua file is interpreted for side effect.
We reuse the code.
<<Lua command-line driver>>=
CMD.interptab[".lua"] = CMD.compilertab[".lua"]
@
{\PAL} source is translated to the interpreter's special assembly code.
<<Lua command-line driver>>=
function CMD.interptab[".c--"](file) 
  local asm = CMD.outfilename(file, '.qs', '.s')
  if Options.verbose > 0 then write('Translating ', file, ' to ', asm, '\n') end
  local emitglobals = Options.globals
  if emitglobals == 1 then Options.globals = nil end
  if Options.verbose < 2 then backend.compile(backend, emitglobals, file, asm) end
  return asm
end
@ 
Assembly code is salted away in [[CMD.qslist]] to be linked.
<<Lua command-line driver>>=
function CMD.interptab[".qs"](file)
  tinsert(CMD.qslist, file)
end
@ 
Unknown extensions are treated like assembly code: they are passed to the
linker.
<<Lua command-line driver>>=
CMD.interptab["unrecognized extension"]=CMD.interptab[".qs"]
@
The interpreter barfs if given native assembly code.
<<Lua command-line driver>>=
function CMD.interptab[".s"](file)
  CMD.error('file ' .. file .. ' is for native code, not the Quick C-- interpreter')
end
@ 
The interpreter's assembly files are actually Lua code.
The ``linking'' step for the interpreter involves simply 
concatenating the assembly files with 
[[CMM.new_assembly_unit()]] after each file.
The head of the file is a [[#!]] line taken from
[[Interp.hashbang]]; finally, the resulting file is marked as
executable.
<<Lua command-line driver>>=
Interp = Interp or {}
Interp.hashbang = "#! /usr/bin/env qc--interp"

function CMD.qs2exe(objs)    
    local exe = Options.output or "a.out"
    if writeto(exe) == nil then CMD.error ("cannot open file " .. exe) end
    write(Interp.hashbang .. "\n")
    local i = 1
    while objs[i] do
        if type (objs[i]) == "string" then
            if readfrom(objs[i]) == nil then
                writeto() -- restore stdout
                CMD.error ("cannot open file "..objs[i]) 
            end
            
            local s = read() -- copy file, line by line
            while s ~= nil do
                write(s)
                write("\n")
                s = read()
            end
            write("CMM.new_assembly_unit()\n")
            readfrom() -- close file, restore stdin
        end
        i = i+1
    end
    writeto() -- close input, restore stdout
    CMD.exec("chmod +x " .. exe)
    return exe
end    
@
\subsection{Stuff for the prettyprinter}
Prettyprinting never continues.
<<Lua command-line driver>>=
CMD.prettytab = { }
function CMD.prettytab['.c--'](file)
  local pp = CMD.outfilename(file, '.pp')
  if Options.verbose > 0 then write('Prettyprinting ', file, ' to ', pp, '\n') end
  if Options.verbose < 2 then Debug.prettyprint(file,pp)                       end
end
CMD.prettytab[".lua"] = CMD.compilertab[".lua"]
function CMD.prettytab['.s'](file)
  CMD.error('qc-- cannot prettyprint ' .. file)
end
CMD.prettytab['.qs'] = CMD.prettytab['.s']
CMD.prettytab['.o']  = CMD.prettytab['.s']
@
% ------------------------------------------------------------------ 
\subsection{Introspection (to support debugging)}
% ------------------------------------------------------------------ 

To support the debugging of Lua code we provide at the very beginning of
the script functions that allow to inspect the interpreter. This way
they are available in the interpreter, even if later parts of the scrip
fail to load.

The module [[Inspect]] provides functions to dump the entire name space of
the interpreter to stdout.

[[Inspect.type]] returns the type of a table entry. It tries to be smart
about userdata.
<<Debugging Tools>>=
Inspect = Inspect and error('Inspect not empty') or {}

function Inspect.type (val)  -- identify the value
    if type(val) == "userdata" then
        local s = tostring(val)
        if strlen(s) < 20 then
            return "userdata " .. s
        else
            return "userdata"
        end
    else
        return type(val)
    end
end
@
[[Inspect.globals]] and [[Inspect.table]] dump the table of all global
variables and a regular table, respectively. Both functions recurse if
they find a table, which they pass to [[Inspect.table]].
<<Debugging Tools>>=
function Inspect.globals ()
    local key,val = nextvar(nil)
    while key do
        Inspect.value(key, val)
        key,val = nextvar(key)
    end
end    

function Inspect.value(key, val)
   if not val then val = key; key = nil end
   write(format ("%-40s%s\n",tostring(key or ""), Inspect.type(val)))
   if type(val) == "table" then Inspect.table (key or '?', val) end
end

function Inspect.table (tabname,table)    -- helper for Inspect.vars 
    local key,val = next(table,nil)
    while key do
        local valname = Inspect.valname(tabname, key)
        Inspect.value(valname, val)
        key,val = next(table,key)
    end
end

function Inspect.valname(tabname, key)
    if type(key) == "string" then
        return tabname .. "." .. key
    else
        return tabname .. "[" .. key .. "]"
    end
end
@ 
<<Debugging Tools>>=
function Inspect.image(x)
  local i, n, v, pfx, s, ty, tag
  if type(x) == 'string' then return format("%q", x)
  elseif type(x) == 'number' then
     if x == floor(x) then return format("%.0f", x)
     else                  return format("%f", x)
     end
  elseif type(x) == 'function' or type(x) == "cfunction" then
       return tostring(x)
  elseif type(x) == 'table' then
        if Util.is_list(x) then s = "{"; pfx = " "
                           i = 1
                           while x[i] do
                             s = s .. pfx .. Inspect.image(x[i])
                             pfx = ", "
                             i = i + 1
                           end
                           return s .. " }"
        else               s = "{\n"; pfx = "  "
                           i = nil
                           n = 0
                           repeat
                             i, v = next(x, i)
                             if (i ~= nil) then
                               s = s .. pfx 
                               if type(i) == "string" and strfind(i, "^[a-zA-Z][a-zA-Z_0-9]*$") then
                                 s = s .. i
                               else
                                 s = s .. "[" .. Inspect.image(i) .. "]"
                               end
                               s = s .. " = " .. Inspect.image(v)
                             end
                             pfx = ",\n  "
                           until (i == nil)
                           return s .. "\n}"
        end
  elseif type(x) == 'nil' then return 'nil'
  else return tostring(x)
  end
end
function Inspect.show(x, a, b, c, d, e)
  local i, n, v, pfx
  write(Inspect.image(x))
  if a then Inspect.show(a, b, c, d, e) end
end
function Util.is_list(list)
  if type(list) ~= "table" then return nil end
  local i = 1
  while list[i] do i = i + 1 end
  i = i - 1
  return i == Util.list_length(list)
end
function Util.list_length(list)
  local i, n, v
  i = nil
  n = 0
  if type(list) ~= "table" then
    errormsg("Length of non-list (", type(list), ") ", Inspect.image(list))
  end
  repeat
    i, v = next(list, i)
    if i ~= nil then
      n = n + 1
    end
  until i == nil
  if list.n == n - 1 then return n - 1 else return n end
end
@
This script is stored as a string in [[Inspect["qc--.lua"]]]. For
convenience we provide an [[Inspect.script]] function that dumps it to
stdout.
<<Debugging Tools>>=
function Inspect.script () write(Boot["qc--.lua"]) end    
@
Function [[Inspect.find]] searches through all tables for a key [[x]] and
returns the path to first [[x]] it finds as a string, or [[nil]].
<<Debugging Tools>>=
function Inspect.find(x)
    local i, v, ii, vv
    -- search global tables for x
    i, v = nextvar(nil)
    while i do
        if type(v) == "table" then
            ii, vv = next(v, nil)
            while ii ~= nil do
                if vv == x then
                    return i .. "." .. ii
                else
                    ii, vv = next(v, ii)
                end
            end
        end
        i, v = nextvar(i)
    end
    -- search globals for x
    i, v = nextvar(nil)
    while i ~= nil do
        if v == x then
            return i
        else
            i, v = nextvar(i)
        end
    end
    return nil
end
@
\subsection{Utility functions}
We insert code from \module{luautil.nw}.
<<Lua utility functions>>=
<<Lua utility functions written in Lua>>
<<list functions>>
@ 
Function [[tinsert]] inserts at the end of a list.
Its interface is (partly) borrowed from Lua~4.0.
<<list functions>>=
function tinsert(l, x)
  local n = l.n
  if not n then
    local i = 1
    while l[i] do i = i + 1 end
    n = i - 1
  end
  l[n+1] = x
  l.n = n + 1
end
@
