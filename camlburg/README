vim: set ts=8 et sw=4: 

------------------------------------------------------------------
 $Id$
------------------------------------------------------------------  

                            MLburg
                            ------
                            
This is a BURG code-generator generator for Objective Caml. It was
inspired by Fraser and Hanson's iBurg: "Engineering a Simple, Efficient
Code Generator Generator", ACM Letters on Programming Languages and
Systems 1, 3 (Sep 1992), 213-226. The code generated by MLburg is
different in the sense that it is separated from the subject tree which
makes it more general.

The user documentation for the program is in the manual page mlburg.1.
An example for using MLburg is in module sample.nw.

Allthough MLburg is a literate program it is easy to miss the big
picture if you want to understand how the generated code works. Below is
some handwritten code that served as an example while developing MLburg. 
        
(*
    
    %term string int
 
    number: ADD(x:number,  y:number)                [2]     { x + y }
    number: ADD(x:number,  NULL())                  [1]     { x     }
    number: ADD(x:number,  ADD(NULL(), z:number))   [1]     { x + z }
    number: CONST(x: int)                                   { x }
    number: 5                                       [0]     { 5 }
    number: v:int                                   [0]     { v }
    
    str   : STR(x: string)                                  { x }
    str   : CONS(x: string, y:string)               [2]     { x ^ y }

    str   : number                   [1]   { string_of_int number }
    number: str                      [1]   { int_of_string str    }

    ------------------------------------------------------------------ 
    Normalized rule set:

    number: ADD(x:number, y:number) [2] { x + y }
    number: ADD(x:number, _v1:_t1)  [1] { x }
    _t1   : NULL()                  [0] { () }
    number: ADD(x:number, _v1:_t2)  [1] { let z  = _v1 in x + z }
    _t2   : ADD(_v1:_t1, z:number)  [0] { let () = _v1 in z } (* re-use t1! *)
    number: CONST(x:int)            [0] { x }
    number: 5                       [0] { 5 }
    number: v:int                   [0] { v } 

    str   : number:number           [1] { string_of_int number }
    number: str:str                 [1] { int_of_string str    }

    str   : STR(x: string)          [0] { x }
    str   : CONS( x: string
                , y: string)        [2] { x ^ y }

*)


(* ------------------------------------------------------------------ *)

type cost = int

type 'a nt = 
    { cost:     cost
    ; action:   unit -> 'a
    }

let inf_cost    = 10000
let infinity = 
    { cost = inf_cost
    ; action = (fun () -> assert false) 
    }

let min x y     = if x.cost < y.cost then x else y
let choice nts  = List.fold_left min (List.hd nts) (List.tl nts)
let matches x y = if x = y then 0 else inf_cost
let (>>) x f    = f x       (* left associative *) 

(* everything below is specification specific and thus generated *)

type ('t1, 't2, 't3, 't4) nonterm =
    { _t1   :   't1     (* unit *)
    ; _t2   :   't2     (* int  *)
    ; str   :   't3     (* string *)
    ; number:   't4     (* int *)
    }

let inf  =
    { _t1    = infinity
    ; _t2    = infinity
    ; str    = infinity
    ; number = infinity
    }


(* ------------------------------------------------------------------ *)
(* one update function per non-terminal *)

let rec update_str nt x =
    if nt.cost >= x.str.cost then
        x
    else
            { x with str = nt }
        >>   fun x -> update_number             (* number: str *)
                    { cost   = nt.cost + 1
                    ; action = fun () -> 
                        let str = x.str.action () in int_of_string str
                    } x     
   
and update_number nt x =
    if nt.cost >= x.number.cost then
        x
    else
            { x with number = nt }
        >>   fun x -> update_str 
                    { cost   = nt.cost + 1      (* str: number *)
                    ; action = fun () -> 
                        let number = x.number.action () in string_of_int number
                    } x    
   
(* non-terminals introduced by normalization never have chain rules *)

and update_t1 nt x =
    if nt.cost >= x._t1.cost then
        x
    else
            { x with _t1 = nt }
        
and update_t2 nt x =
    if nt.cost >= x._t2.cost then
        x
    else
            { x with _t2 = nt }
        


(* ------------------------------------------------------------------ *)
(* one function per constructor *)

let add = fun arg1 arg2 ->  
        inf 
    >>  update_number     
            ( choice 
            [ { cost   = arg1.number.cost + arg2.number.cost + 2
              ; action = fun () ->
                    let x  = arg1.number.action () in
                    let y  = arg2.number.action () in
                        x + y
              }
            ; { cost   = arg1.number.cost + arg2._t1.cost + 1
              ; action = fun () ->
                    let x  = arg1.number.action () in
                        x
              }
            ; { cost   = arg1.number.cost + arg2._t2.cost + 1
              ; action = fun () ->
                    let x   = arg1.number.action () in
                    let _v1 = arg2._t2.action () in 
                    let z   = _v1 in
                        x + z
              }
            ])
    >>  update_t2
            { cost   = arg1._t1.cost + arg2.number.cost 
            ; action = fun () ->
                    let _v1 = arg1._t1.action () in
                    let z   = arg2.number.action () in
                    let ()  = _v1 in
                        z
            } 
        

let null = fun () ->  
    inf >> update_t1 { cost = 0 ; action = fun () -> () }

let const = fun (x:int) ->
    inf >> update_number { cost = 0 ; action = fun () -> x }

let str = fun (x:string) -> 
    inf >> update_str { cost = 0 ; action = fun () -> x }

let cons = fun (x:string) (y:string) -> 
    inf >> update_str { cost = 2 ; action = fun () -> x ^ y }

(* one function per literal on the top-level *)

let five = fun () ->
    inf >> update_number { cost = 0; action = fun () -> 5 }

(* one function per terminal variable on the top-level *)
let var_v = fun (v:int) ->
    inf >> update_number { cost = 0; action = fun () -> v }

(* ------------------------------------------------------------------ *)
(* The client *)

module D = struct 
    type number =
        | Add       of number * number
        | Const     of int
        | Null
        | Str       of str

    and str =       
        | String    of string
        | Cons      of string * string
        | Number    of number

    let add x y     = Add(x,y)
    let const x     = Const(x)
    let null        = Null
    let str s       = Str(s)

    let string s    = String(s)
    let cons x y    = Cons(x,y)
    let number x    = Number(x)

    let exp0 =
        add 
            (add 
                (const 3) 
                (const 7)) 
            (null)

    let exp1 =
        add 
            (add 
                (str (string "123"))
                (str (number (const 8))))
            (add 
                (null)
                (const 7)) 

end

(* ------------------------------------------------------------------ *)

let rec fold_num = function
    | D.Add(l,r) -> add (fold_num l) (fold_num r)
    | D.Const(x) -> const x
    | D.Null     -> null ()
    | D.Str(s)   -> fold_str s

and fold_str = function
    | D.String(x) -> str x
    | D.Cons(x,y) -> cons x y
    | D.Number(n) -> fold_num n


